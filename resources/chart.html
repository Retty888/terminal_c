<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <style>
    html, body { margin:0; padding:0; height:100%; }
    #container { position:relative; width:100%; height:100%; }
    #tvchart { width:100%; height:100%; }
    #toolbar { position:absolute; left:0; top:0; z-index:10; display:flex; flex-direction:column; }
    #toolbar button, #toolbar select { height:32px; margin:2px; background:#222; color:#fff; border:none; cursor:pointer; }
    #toolbar button { width:48px; }
    #toolbar button.active { background:#555; }
    #overlay { position:absolute; left:0; top:0; z-index:5; }
  </style>
</head>
<body>
<div id="container">
  <div id="toolbar">
    <select id="series-select">
      <option value="CandlestickSeries">CandlestickSeries</option>
      <option value="LineSeries">LineSeries</option>
      <option value="AreaSeries">AreaSeries</option>
    </select>
    <button id="tool-cross" data-tool="cross">‚úñ</button>
    <button id="tool-ruler" data-tool="ruler">üìè</button>
    <button id="tool-trend" data-tool="trend">Ôºè</button>
    <button id="tool-long" data-tool="long">Long</button>
    <button id="tool-short" data-tool="short">Short</button>
  </div>
  <div id="tvchart"></div>
  <canvas id="overlay"></canvas>
</div>
<script src="lightweight-charts.standalone.production.js"></script>
<script>
  const container = document.getElementById('container');
  const chartEl = document.getElementById('tvchart');
  const overlay = document.getElementById('overlay');

  const chart = LightweightCharts.createChart(chartEl, {
    width: container.clientWidth,
    height: container.clientHeight,
    localization: { locale: 'ru-RU' },
    timeScale: { timeVisible: true, secondsVisible: false }
  });
  let series = chart.addCandlestickSeries();
  let markers = [];
  let priceLine = null;
  const data = [];
  const ctx = overlay.getContext('2d');

  function resize() {
    const w = container.clientWidth;
    const h = container.clientHeight;
    chart.applyOptions({ width: w, height: h });
    overlay.width = w;
    overlay.height = h;
    redraw();
  }
  window.addEventListener('resize', resize);
  resize();

  let currentTool = 'cross';
  let drawing = null;
  const drawings = [];
  const positions = [];
  let positionId = 0;

  function setActiveTool(t) {
    currentTool = t;
    document.querySelectorAll('#toolbar button').forEach(b => {
      b.classList.toggle('active', b.dataset.tool === t);
    });
    overlay.style.pointerEvents = t === 'cross' ? 'none' : 'auto';
  }
  window.setActiveTool = setActiveTool;

  function selectTool(t) {
    setActiveTool(t);
    if (typeof setTool === 'function') setTool(t);
  }

  document.querySelectorAll('#toolbar button').forEach(b => {
    b.addEventListener('click', () => selectTool(b.dataset.tool));
  });

  const seriesSelect = document.getElementById('series-select');

  function createSeries(t) {
    if (series) {
      chart.removeSeries(series);
    }
    if (t === 'LineSeries') {
      series = chart.addLineSeries();
    } else if (t === 'AreaSeries') {
      series = chart.addAreaSeries();
    } else {
      series = chart.addCandlestickSeries();
    }
    series.setData(data);
    if (markers.length) series.setMarkers(markers);
    if (priceLine !== null) series.createPriceLine({ price: priceLine });
  }

  function setActiveSeries(t) {
    seriesSelect.value = t;
    createSeries(t);
  }
  window.setActiveSeries = setActiveSeries;

  function selectSeries(t) {
    setActiveSeries(t);
    if (typeof setSeries === 'function') setSeries(t);
  }

  seriesSelect.addEventListener('change', () => selectSeries(seriesSelect.value));

  function redraw() {
    ctx.clearRect(0, 0, overlay.width, overlay.height);
    drawings.forEach(d => {
      const x1 = chart.timeScale().timeToCoordinate(d.time1);
      const y1 = series.priceToCoordinate(d.price1);
      const x2 = chart.timeScale().timeToCoordinate(d.time2);
      const y2 = series.priceToCoordinate(d.price2);
      ctx.strokeStyle = 'yellow';
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      if (d.tool === 'ruler') {
        const diff = d.price2 - d.price1;
        const pct = diff / d.price1 * 100;
        ctx.fillStyle = 'yellow';
        ctx.fillText(diff.toFixed(2) + ' (' + pct.toFixed(2) + '%)', x2 + 5, y2 + 5);
      }
    });
    positions.forEach(p => {
      const x1 = chart.timeScale().timeToCoordinate(p.time1);
      const y1 = series.priceToCoordinate(p.price1);
      const x2 = chart.timeScale().timeToCoordinate(p.time2);
      const y2 = series.priceToCoordinate(p.price2);
      ctx.fillStyle = p.tool === 'long' ? 'rgba(0,255,0,0.2)' : 'rgba(255,0,0,0.2)';
      ctx.strokeStyle = p.tool === 'long' ? 'green' : 'red';
      ctx.beginPath();
      ctx.rect(x1, y1, x2 - x1, y2 - y1);
      ctx.fill();
      ctx.stroke();
      const diff = p.tool === 'long' ? p.price2 - p.price1 : p.price1 - p.price2;
      const pct = diff / p.price1 * 100;
      const arrowX = Math.max(x1, x2) + 10;
      ctx.strokeStyle = diff >= 0 ? 'green' : 'red';
      ctx.beginPath();
      ctx.moveTo(arrowX, y1);
      ctx.lineTo(arrowX, y2);
      ctx.stroke();
      ctx.beginPath();
      const dir = y2 < y1 ? -1 : 1;
      ctx.moveTo(arrowX - 5, y2 + 5 * dir);
      ctx.lineTo(arrowX, y2);
      ctx.lineTo(arrowX + 5, y2 + 5 * dir);
      ctx.stroke();
      ctx.fillStyle = diff >= 0 ? 'green' : 'red';
      ctx.fillText(diff.toFixed(2) + ' (' + pct.toFixed(2) + '%)', arrowX + 5, (y1 + y2) / 2);
    });
  }

  overlay.addEventListener('mousedown', e => {
    if (currentTool === 'cross') return;
    const x = e.offsetX;
    const y = e.offsetY;
    drawing = {
      x1: x,
      y1: y,
      time1: chart.timeScale().coordinateToTime(x),
      price1: series.coordinateToPrice(y)
    };
  });

  overlay.addEventListener('mousemove', e => {
    if (!drawing) return;
    redraw();
    const x = e.offsetX;
    const y = e.offsetY;
    ctx.strokeStyle = 'yellow';
    ctx.fillStyle = 'yellow';
    if (currentTool === 'trend' || currentTool === 'ruler') {
      ctx.beginPath();
      ctx.moveTo(drawing.x1, drawing.y1);
      ctx.lineTo(x, y);
      ctx.stroke();
      if (currentTool === 'ruler') {
        const price2 = series.coordinateToPrice(y);
        const diff = price2 - drawing.price1;
        const pct = diff / drawing.price1 * 100;
        ctx.fillText(diff.toFixed(2) + ' (' + pct.toFixed(2) + '%)', x + 5, y + 5);
      }
    } else if (currentTool === 'long' || currentTool === 'short') {
      ctx.fillStyle = currentTool === 'long' ? 'rgba(0,255,0,0.2)' : 'rgba(255,0,0,0.2)';
      ctx.strokeStyle = currentTool === 'long' ? 'green' : 'red';
      ctx.beginPath();
      ctx.rect(drawing.x1, drawing.y1, x - drawing.x1, y - drawing.y1);
      ctx.fill();
      ctx.stroke();
    }
  });

  overlay.addEventListener('mouseup', e => {
    if (!drawing) return;
    const x = e.offsetX;
    const y = e.offsetY;
    drawing.x2 = x;
    drawing.y2 = y;
    drawing.time2 = chart.timeScale().coordinateToTime(x);
    drawing.price2 = series.coordinateToPrice(y);
    drawing.tool = currentTool;
    if (currentTool === 'long' || currentTool === 'short') {
      addPosition(drawing);
    } else {
      drawings.push(drawing);
      redraw();
    }
    drawing = null;
  });

  window.updateCandle = function(c) {
    if (data.length && data[data.length - 1].time === c.time) {
      data[data.length - 1] = c;
      series.update(c);
    } else {
      data.push(c);
      series.update(c);
    }
  };
  window.chart = {
    setMarkers: function(m) { markers = m; series.setMarkers(m); },
    setPriceLine: function(p) { priceLine = p; series.createPriceLine({ price: p }); }
  };

  function addPosition(p) {
    if (p.id === undefined) {
      p.id = positionId++;
    } else {
      positionId = Math.max(positionId, p.id + 1);
    }
    positions.push(p);
    redraw();
    return p.id;
  }
  function removePosition(id) {
    const idx = positions.findIndex(p => p.id === id);
    if (idx !== -1) {
      positions.splice(idx, 1);
      redraw();
    }
  }
  function updatePosition(p) {
    const idx = positions.findIndex(x => x.id === p.id);
    if (idx !== -1) {
      positions[idx] = { ...positions[idx], ...p };
      redraw();
    }
  }
  window.addPosition = addPosition;
  window.removePosition = removePosition;
  window.updatePosition = updatePosition;
  window.getPositions = () => positions;
</script>
</body>
</html>
