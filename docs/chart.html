<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <style>
    html, body { margin:0; padding:0; height:100%; }
    #container { position:relative; width:100%; height:100%; }
    #tvchart { width:100%; height:100%; background:#ffffff; }
    #toolbar { position:absolute; left:0; top:0; z-index:10; display:flex; flex-direction:column; }
    #toolbar button, #toolbar select { height:32px; margin:2px; background:#e6e6e6; color:#000; border:1px solid #c8c8c8; cursor:pointer; }
    #toolbar button { width:72px; }
    #toolbar button.active { background:#cfcfcf; }
    #overlay { position:absolute; left:0; top:0; z-index:5; }
    #coords { position:absolute; right:0; bottom:0; z-index:10; background:#f2f2f2; color:#000; border:1px solid #d0d0d0; padding:2px 4px; font-family:monospace; }
  </style>
  <title>Chart</title>
  <!-- CSP removed to avoid blocking local file:// scripts in WebView2. -->
  </head>
<body>
<div id="container">
  <div id="toolbar">
    <select id="interval-select"></select>
    <select id="series-select">
      <option value="CandlestickSeries">CandlestickSeries</option>
      <option value="LineSeries">LineSeries</option>
      <option value="AreaSeries">AreaSeries</option>
    </select>
    <button id="fit-btn">Fit</button>
    <button id="tool-cross" data-tool="cross">Cross</button>
    <button id="tool-ruler" data-tool="ruler">Ruler</button>
    <button id="tool-trend" data-tool="trend">Trend</button>
    <button id="tool-long" data-tool="long">Long</button>
    <button id="tool-short" data-tool="short">Short</button>
    <button id="tool-fibo" data-tool="fibo">Fibo</button>
  </div>
  <div id="tvchart"></div>
  <canvas id="overlay"></canvas>
  <div id="coords"></div>
</div>
<script>
  let __lastStatusMsg = null, __lastStatusAt = 0;
  function __status(msg){
    try {
      const now = Date.now();
      const str = String(msg);
      // Forward all status messages for debugging
      if (typeof appStatus === 'function') appStatus(str);
      try { console.log('[chart]', str); } catch(e){}
    } catch(e){}
  }
  window.addEventListener('error', function(e){ __status('js-error: '+(e && e.message)); });
  document.addEventListener('DOMContentLoaded', function(){ __status('dom-content-loaded'); });
</script>
<script src="lightweight-charts.standalone.production.js"></script>
<script> if (!window.LightweightCharts) { __status('lc-missing'); } else { __status('lc-loaded'); } </script>
<script>
  const container = document.getElementById('container');
  const chartEl = document.getElementById('tvchart');
  const overlay = document.getElementById('overlay');
  const coordsEl = document.getElementById('coords');
  const intervalSelect = document.getElementById('interval-select');
  const seriesSelect = document.getElementById('series-select');

  __status('init-script-start');
  const chart = LightweightCharts.createChart(chartEl, {
    width: container.clientWidth,
    height: container.clientHeight,
    layout: {
      background: { color: '#ffffff' },
      textColor: '#111111',
    },
    grid: {
      vertLines: { color: '#e6e6e6' },
      horzLines: { color: '#e6e6e6' },
    },
    crosshair: {
      color: '#999999',
    },
    rightPriceScale: {
      borderColor: '#bfbfbf',
    },
    timeScale: {
      timeVisible: true,
      secondsVisible: false,
      borderColor: '#bfbfbf',
    },
    localization: {
      locale: 'ru-RU',
    },
  });
  __status('chart-created');
  let series = chart.addCandlestickSeries({
    upColor: '#f2f2f2',
    downColor: '#404040',
    borderUpColor: '#111111',
    borderDownColor: '#111111',
    wickUpColor: '#111111',
    wickDownColor: '#111111',
  });
  const originalSetData = series.setData;
  series.setData = function(arr) {
    if (arr && arr.length > 0) {
      __status('setData[0]: ' + JSON.stringify(arr[0]));
    }
    originalSetData.call(this, arr);
  };
  let markers = [];
  let priceLineValue = null;
  let priceLineHandle = null;
  const data = [];
  const ctx = overlay.getContext('2d');
  chart.subscribeCrosshairMove(param => {
    try {
      if (!param || !param.time || !param.point) { coordsEl.textContent = ''; return; }
      let price;
      if (param.seriesPrices && typeof param.seriesPrices.get === 'function') {
        price = param.seriesPrices.get(series);
      } else if (param.seriesData && typeof param.seriesData === 'object') {
        // Fallback for older/newer API shapes
        const v = param.seriesData.value || param.seriesData;
        price = (typeof v === 'object' && v && 'close' in v) ? v.close : v;
      }
      // Show human-friendly RU format in UTC to match candle times
      const ts = new Date(param.time * 1000).toLocaleString('ru-RU', {
        year: '2-digit', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit'
      });
      coordsEl.textContent = `${ts} ${price !== undefined ? Number(price).toFixed(2) : ''}`;
    } catch(e) {
      __status('crosshair-error: '+(e && e.message));
    }
  });

  // Declare state BEFORE first resize/redraw to avoid TDZ on 'drawings'
  let currentTool = 'cross';
  let drawing = null;
  const drawings = [];
  const positions = [];
  let positionId = 0;

  function resize() {
    const w = container.clientWidth;
    const h = container.clientHeight;
    chart.applyOptions({ width: w, height: h });
    overlay.width = w; overlay.height = h;
    redraw();
  }
  window.addEventListener('resize', resize);
  resize();
  // Notify native right after initial layout (one-time)
  try {
    if (!window._appReadySent && typeof appReady === 'function') { appReady('ok'); window._appReadySent = true; }
  } catch(e){}

  function setActiveTool(t) {
    currentTool = t;
    document.querySelectorAll('#toolbar button[data-tool]').forEach(b => {
      b.classList.toggle('active', b.dataset.tool === t);
    });
    overlay.style.pointerEvents = (t === 'cross') ? 'none' : 'auto';
  }
  window.setActiveTool = setActiveTool;

  function selectTool(t) {
    setActiveTool(t);
    if (typeof appSetTool === 'function') appSetTool(t);
  }
  document.querySelectorAll('#toolbar button[data-tool]').forEach(b => {
    b.addEventListener('click', () => selectTool(b.dataset.tool));
  });

  document.getElementById('fit-btn').addEventListener('click', () => {
    chart.timeScale().fitContent();
    chart.timeScale().scrollToRealTime();
  });

  function createSeries(t) {
    if (series) chart.removeSeries(series);
    if (t === 'LineSeries') {
      series = chart.addLineSeries({ color: '#333333', lineWidth: 2 });
    } else if (t === 'AreaSeries') {
      series = chart.addAreaSeries({ lineColor: '#333333', topColor: 'rgba(0,0,0,0.10)', bottomColor: 'rgba(0,0,0,0.02)' });
    } else {
      series = chart.addCandlestickSeries({
        upColor: '#f2f2f2',
        downColor: '#404040',
        borderUpColor: '#111111',
        borderDownColor: '#111111',
        wickUpColor: '#111111',
        wickDownColor: '#111111',
      });
    }
    series.setData(data);
    __status('series-added');
    if (markers.length) series.setMarkers(markers);
    if (priceLineHandle) { try { priceLineHandle.remove(); } catch(e){} priceLineHandle = null; }
    if (priceLineValue !== null) {
      try { priceLineHandle = series.createPriceLine({ price: priceLineValue }); } catch(e){}
    }
  }
  function setActiveSeries(t) { seriesSelect.value = t; createSeries(t); }
  window.setActiveSeries = setActiveSeries;
  function selectSeries(t) { setActiveSeries(t); if (typeof appSetSeries === 'function') appSetSeries(t); }
  seriesSelect.addEventListener('change', () => selectSeries(seriesSelect.value));

  // Interval change â†’ notify native side via bound function if present
  intervalSelect.addEventListener('change', () => {
    const iv = intervalSelect.value;
    if (typeof appSetInterval === 'function') appSetInterval(iv);
    if (typeof appStatus === 'function') appStatus('Interval: ' + iv);
  });

  // Allow native side to push intervals and active selection
  window.setIntervals = function(list) {
    const current = intervalSelect.value;
    intervalSelect.innerHTML = '';
    (list || []).forEach(iv => {
      const opt = document.createElement('option');
      opt.value = iv; opt.textContent = iv; intervalSelect.appendChild(opt);
    });
    if (current && list && list.includes(current)) intervalSelect.value = current;
  };
  window.setActiveInterval = function(iv) {
    if (!iv) return;
    intervalSelect.value = iv;
  };

  function redraw() {
    ctx.clearRect(0, 0, overlay.width, overlay.height);
    drawings.forEach(d => {
      const x1 = chart.timeScale().timeToCoordinate(d.time1);
      const y1 = series.priceToCoordinate(d.price1);
      const x2 = chart.timeScale().timeToCoordinate(d.time2);
      const y2 = series.priceToCoordinate(d.price2);
      ctx.strokeStyle = '#808080';
      ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
    });
    positions.forEach(p => {
      const x1 = chart.timeScale().timeToCoordinate(p.time1);
      const y1 = series.priceToCoordinate(p.price1);
      const x2 = chart.timeScale().timeToCoordinate(p.time2);
      const y2 = series.priceToCoordinate(p.price2);
      ctx.fillStyle = p.tool === 'long' ? 'rgba(0,0,0,0.12)' : 'rgba(0,0,0,0.20)';
      ctx.strokeStyle = p.tool === 'long' ? '#666666' : '#222222';
      ctx.beginPath(); ctx.rect(x1, y1, x2 - x1, y2 - y1); ctx.fill(); ctx.stroke();
    });
  }

  overlay.addEventListener('mousedown', e => {
    if (currentTool === 'cross') return;
    const x = e.offsetX; const y = e.offsetY;
    drawing = { x1: x, y1: y, time1: chart.timeScale().coordinateToTime(x), price1: series.coordinateToPrice(y), tool: currentTool };
  });
  overlay.addEventListener('mousemove', e => {
    if (!drawing) return; redraw();
    const x = e.offsetX; const y = e.offsetY;
    ctx.strokeStyle = 'yellow'; ctx.beginPath(); ctx.moveTo(drawing.x1, drawing.y1); ctx.lineTo(x, y); ctx.stroke();
  });
  overlay.addEventListener('mouseup', e => {
    if (!drawing) return;
    const x = e.offsetX; const y = e.offsetY;
    drawing.x2 = x; drawing.y2 = y; drawing.time2 = chart.timeScale().coordinateToTime(x); drawing.price2 = series.coordinateToPrice(y);
    positions.push(drawing); drawing = null; redraw();
  });

  // API used by native side
  window.updateCandle = function(c) {
    __status('updateCandle: ' + JSON.stringify(c));
    if (data.length && data[data.length - 1].time === c.time) {
      data[data.length - 1] = c; series.update(c);
    } else { data.push(c); series.update(c); }
  };
  window.chart = {
    setMarkers: function(m) { markers = m; try { series.setMarkers(m); } catch(e){} },
    setPriceLine: function(p) {
      try { if (priceLineHandle) { priceLineHandle.remove(); priceLineHandle = null; } } catch(e){}
      if (p === null || p === undefined || Number.isNaN(Number(p))) { priceLineValue = null; return; }
      priceLineValue = Number(p);
      try { priceLineHandle = series.createPriceLine({ price: priceLineValue }); } catch(e){}
    }
  };
  window.addPosition = function(p) { p.id = p.id ?? (positionId++); positions.push(p); redraw(); return p.id; };
  window.removePosition = function(id) { const i = positions.findIndex(p => p.id === id); if (i !== -1) { positions.splice(i,1); redraw(); } };
  window.updatePosition = function(p) { const i = positions.findIndex(x => x.id === p.id); if (i !== -1) { positions[i] = { ...positions[i], ...p }; redraw(); } };
  window.getPositions = () => positions;
  // Notify native side when the page is loaded and JS is ready.
  (function(){
    __status('page-loading');
    const notify = () => { if (typeof appReady === 'function') appReady('ok'); };
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(notify, 0);
    } else {
      window.addEventListener('DOMContentLoaded', notify);
    }
  })();
</script>
</body>
</html>
